module eDVSinput(
input wire clk,
input wire reset,
output wire [7:0] rx_byte,
output wire transmitting,
output wire recieveing);
			
// eDVS start and stop bits
localparam start_bit = "+E\n";
localparam stop_bit = "-E\n";

wire [7:0] rx_byte;
reg transmit;
integer byteN = 0;

// STATE MACHINE
localparam START = 0; 
localparam TXD_START = START + 1; // transmitt start bit 
localparam RECIEVE = TXD_START +1; // recieve data
localparam STOP = RECIEVE + 1; // transmitt data and stop recieveing data
localparam TXD_STOP = STOP + 1;
localparam ERROR = TXD_STOP + 1;

reg [2:0] state = 3'b0;
reg [31:0] tbyte;

always @(posedge clk or posedge reset)
begin
	if(reset) begin
		state = START;
		byteN = 1;
		rec_loop = 1'b0;
	end
	else begin
		case (state)
			START: begin
			// if the key is pressed then transmit the start bit and move to txd_state
			// In this step we set up for the start transmission 
			// We want to send the bits E+/n		
				tbyte = start_bit[7:0];
				transmit = 1'b1;
				byteN = 1;
				state = TXD_START;		
			end
			TXD_START: begin
			//send the start bit and move to rxd_state
			if (!transmitting && !transmit) begin
					tbyte = start_bit[8*byteN +: 8];
					transmit = 1'b1;
					byteN = byteN +1;
					if (byteN ==4)
						state = RECIEVE;
			end else begin 
					transmit = 1'b0;
				end					
			end
			RECIEVE: begin
			// stay in rxd_state until error or until the reset button has been pressed
				transmit = 1'b0;
				#10_000;
			end
			STOP: begin
			// if the key is pressed then transmit the start bit and move to txd_state
			// In this step we set up for the start transmission 
			// We want to send the bits E+/n		
				tbyte = stop_bit;
				transmit = 1'b1;
				byteN = 1;
				if (!transmitting) begin
					//transmit = 1'b0;
					state = TXD_STOP;
				end
				//transmit_bit <= start_bit;					
				//state <= state +1;				
			end
			TXD_STOP: begin
				transmit = 1'b0;
			//send the start bit and move to rxd_state
//				if (!transmit) begin
//					tbyte = start_bit[byteN*8 +: 8];
//					transmit = 1'b1;
//					//state <= state +1;			
//					byteN = byteN +1;
//					if (byteN == 4) begin
//						state = START;
//					end
//				end else begin 
//					transmit = 1'b0;
//				end					
			end		
			
		endcase
	end
end


			
//////////////////////////////////////////////////////
/*           UART TRASMITTER / RECIEVER             */
//////////////////////////////////////////////////////

wire rxclk_en, txclk_en;

baud_rate_gen uart_baud(.clk_50m(clk),
			.rxclk_en(rxclk_en),
			.txclk_en(txclk_en));
transmitter uart_tx(.din(tbyte),
		    .wr_en(transmit),
		    .clk_50m(clk),
		    .clken(txclk_en),
		    .tx(GPIO_0[3]),
		    .tx_busy(transmitting));
			 
receiver uart_rx(.rx(GPIO_0[2]),
		 .rdy(GPIO_0[1]),
		 .rdy_clr(GPIO_0[0]),
		 .clk_50m(clk),
		 .clken(rxclk_en),
		 .data(rx_byte),
		 .is_receiving(recieveing)
		 );

endmodule